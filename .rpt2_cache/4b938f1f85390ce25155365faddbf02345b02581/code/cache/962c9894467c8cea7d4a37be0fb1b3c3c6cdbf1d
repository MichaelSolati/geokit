{"code":"import { base32, decimalChunk, getBit, toRad, validateCoordinates } from './helpers';\r\n/**\r\n * A class for the Geokit.\r\n */\r\nvar Geokit = /** @class */ (function () {\r\n    function Geokit() {\r\n    }\r\n    /**\r\n     * Get the distance between two coordinates.\r\n     * @param start Starting coordinates.\r\n     * @param end Ending coordinates.\r\n     * @param unit Unit of distance returned, defaults to Km.\r\n     * @returns The distance between two coordinates.\r\n     */\r\n    Geokit.distance = function (start, end, unit) {\r\n        if (unit === void 0) { unit = 'km'; }\r\n        var startValid = validateCoordinates(start);\r\n        if (startValid instanceof Error) {\r\n            throw new Error('Start coordinates: ' + startValid.message);\r\n        }\r\n        var endValid = validateCoordinates(end);\r\n        if (endValid instanceof Error) {\r\n            throw new Error('End coordinates: ' + endValid.message);\r\n        }\r\n        var radius = (unit.toLowerCase() === 'miles') ? 3963 : 6371;\r\n        var dLat = toRad(end.lat - start.lat);\r\n        var dLon = toRad(end.lng - start.lng);\r\n        var lat1 = toRad(start.lat);\r\n        var lat2 = toRad(end.lat);\r\n        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n            Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);\r\n        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n        return (radius * c);\r\n    };\r\n    /**\r\n     * Get the geohash of a point.\r\n     * @param coordinates Coordinates to hash.\r\n     * @param precision Precision of hash desired, defaults to 10.\r\n     * @returns Geohash of point.\r\n     */\r\n    Geokit.hash = function (coordinates, precision) {\r\n        if (precision === void 0) { precision = 10; }\r\n        var valid = validateCoordinates(coordinates);\r\n        if (valid instanceof Error) {\r\n            throw valid;\r\n        }\r\n        var hash = '';\r\n        var latRng = [-90, 90];\r\n        var lngRng = [-180, 180];\r\n        while (hash.length < precision) {\r\n            var temp = 0;\r\n            for (var i = 0; i < 5; i++) {\r\n                var even = (((hash.length * 5) + i) % 2) == 0;\r\n                var coord = (even) ? coordinates.lng : coordinates.lat;\r\n                var range = (even) ? lngRng : latRng;\r\n                var middle = (range[0] + range[1]) / 2;\r\n                temp = (temp << 1) + getBit(coord, range);\r\n                (coord > middle) ? range[0] = middle : range[1] = middle;\r\n            }\r\n            hash += base32(temp);\r\n        }\r\n        return hash;\r\n    };\r\n    /**\r\n     * Decodes a Geohash into a LatLngLiteral.\r\n     * @param hash Geohash string.\r\n     * @returns Coordinates to hash.\r\n     */\r\n    Geokit.decodeHash = function (hash) {\r\n        var even = true;\r\n        var latRng = [-90, 90];\r\n        var lngRng = [-180, 180];\r\n        var hashChars = hash.split('');\r\n        while (hashChars.length) {\r\n            var chunk = decimalChunk(hashChars.shift());\r\n            for (var i = 0; i < 5; i++) {\r\n                var mask = [16, 8, 4, 2, 1][i];\r\n                var range = (even) ? lngRng : latRng;\r\n                var middle = (range[0] + range[1]) / 2;\r\n                range[((chunk & mask) ? 0 : 1)] = middle;\r\n                even = !even;\r\n            }\r\n        }\r\n        return { lat: ((latRng[0] + latRng[1]) / 2), lng: ((lngRng[0] + lngRng[1]) / 2) };\r\n    };\r\n    return Geokit;\r\n}());\r\nexport { Geokit };\r\n","dts":{"name":"/Users/michaelsolati/Documents/workspace/geokit/geokit.d.ts","text":"import { LatLngLiteral } from './interfaces';\r\n/**\r\n * A class for the Geokit.\r\n */\r\nexport declare class Geokit {\r\n    /**\r\n     * Get the distance between two coordinates.\r\n     * @param start Starting coordinates.\r\n     * @param end Ending coordinates.\r\n     * @param unit Unit of distance returned, defaults to Km.\r\n     * @returns The distance between two coordinates.\r\n     */\r\n    static distance(start: LatLngLiteral, end: LatLngLiteral, unit?: string): number;\r\n    /**\r\n     * Get the geohash of a point.\r\n     * @param coordinates Coordinates to hash.\r\n     * @param precision Precision of hash desired, defaults to 10.\r\n     * @returns Geohash of point.\r\n     */\r\n    static hash(coordinates: LatLngLiteral, precision?: number): string;\r\n    /**\r\n     * Decodes a Geohash into a LatLngLiteral.\r\n     * @param hash Geohash string.\r\n     * @returns Coordinates to hash.\r\n     */\r\n    static decodeHash(hash: string): LatLngLiteral;\r\n}\r\n"}}
